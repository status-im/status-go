// Code generated by protoc-gen-go. DO NOT EDIT.
// source: chat_identity.proto

package protobuf

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// SourceType are the predefined types of image source allowed
type IdentityImage_SourceType int32

const (
	IdentityImage_UNKNOWN_SOURCE_TYPE IdentityImage_SourceType = 0
	// RAW_PAYLOAD image byte data
	IdentityImage_RAW_PAYLOAD IdentityImage_SourceType = 1
	// ENS_AVATAR uses the ENS record's resolver get-text-data.avatar data
	// The `payload` field will be ignored if ENS_AVATAR is selected
	// The application will read and parse the ENS avatar data as image payload data, URLs will be ignored
	// The parent `ChatMessageIdentity` must have a valid `ens_name` set
	IdentityImage_ENS_AVATAR IdentityImage_SourceType = 2
)

var IdentityImage_SourceType_name = map[int32]string{
	0: "UNKNOWN_SOURCE_TYPE",
	1: "RAW_PAYLOAD",
	2: "ENS_AVATAR",
}

var IdentityImage_SourceType_value = map[string]int32{
	"UNKNOWN_SOURCE_TYPE": 0,
	"RAW_PAYLOAD":         1,
	"ENS_AVATAR":          2,
}

func (x IdentityImage_SourceType) String() string {
	return proto.EnumName(IdentityImage_SourceType_name, int32(x))
}

func (IdentityImage_SourceType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7a652489000a5879, []int{1, 0}
}

// ChatIdentity represents the user defined identity associated with their public chat key
type ChatIdentity struct {
	// Lamport timestamp of the message
	Clock uint64 `protobuf:"varint,1,opt,name=clock,proto3" json:"clock,omitempty"`
	// ens_name is the valid ENS name associated with the chat key
	EnsName string `protobuf:"bytes,2,opt,name=ens_name,json=ensName,proto3" json:"ens_name,omitempty"`
	// images is a string indexed mapping of images associated with an identity
	Images map[string]*IdentityImage `protobuf:"bytes,3,rep,name=images,proto3" json:"images,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// display name is the user set identity
	DisplayName string `protobuf:"bytes,4,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	// description is the user set description
	Description string        `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	Color       string        `protobuf:"bytes,6,opt,name=color,proto3" json:"color,omitempty"`
	Emoji       string        `protobuf:"bytes,7,opt,name=emoji,proto3" json:"emoji,omitempty"`
	SocialLinks []*SocialLink `protobuf:"bytes,8,rep,name=social_links,json=socialLinks,proto3" json:"social_links,omitempty"`
	// first known message timestamp in seconds (valid only for community chats for now)
	// 0 - unknown
	// 1 - no messages
	FirstMessageTimestamp uint32   `protobuf:"varint,9,opt,name=first_message_timestamp,json=firstMessageTimestamp,proto3" json:"first_message_timestamp,omitempty"`
	XXX_NoUnkeyedLiteral  struct{} `json:"-"`
	XXX_unrecognized      []byte   `json:"-"`
	XXX_sizecache         int32    `json:"-"`
}

func (m *ChatIdentity) Reset()         { *m = ChatIdentity{} }
func (m *ChatIdentity) String() string { return proto.CompactTextString(m) }
func (*ChatIdentity) ProtoMessage()    {}
func (*ChatIdentity) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a652489000a5879, []int{0}
}

func (m *ChatIdentity) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ChatIdentity.Unmarshal(m, b)
}
func (m *ChatIdentity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ChatIdentity.Marshal(b, m, deterministic)
}
func (m *ChatIdentity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChatIdentity.Merge(m, src)
}
func (m *ChatIdentity) XXX_Size() int {
	return xxx_messageInfo_ChatIdentity.Size(m)
}
func (m *ChatIdentity) XXX_DiscardUnknown() {
	xxx_messageInfo_ChatIdentity.DiscardUnknown(m)
}

var xxx_messageInfo_ChatIdentity proto.InternalMessageInfo

func (m *ChatIdentity) GetClock() uint64 {
	if m != nil {
		return m.Clock
	}
	return 0
}

func (m *ChatIdentity) GetEnsName() string {
	if m != nil {
		return m.EnsName
	}
	return ""
}

func (m *ChatIdentity) GetImages() map[string]*IdentityImage {
	if m != nil {
		return m.Images
	}
	return nil
}

func (m *ChatIdentity) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *ChatIdentity) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ChatIdentity) GetColor() string {
	if m != nil {
		return m.Color
	}
	return ""
}

func (m *ChatIdentity) GetEmoji() string {
	if m != nil {
		return m.Emoji
	}
	return ""
}

func (m *ChatIdentity) GetSocialLinks() []*SocialLink {
	if m != nil {
		return m.SocialLinks
	}
	return nil
}

func (m *ChatIdentity) GetFirstMessageTimestamp() uint32 {
	if m != nil {
		return m.FirstMessageTimestamp
	}
	return 0
}

// ProfileImage represents data associated with a user's profile image
type IdentityImage struct {
	// payload is a context based payload for the profile image data,
	// context is determined by the `source_type`
	Payload []byte `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
	// source_type signals the image payload source
	SourceType IdentityImage_SourceType `protobuf:"varint,2,opt,name=source_type,json=sourceType,proto3,enum=protobuf.IdentityImage_SourceType" json:"source_type,omitempty"`
	// image_type signals the image type and method of parsing the payload
	ImageType ImageType `protobuf:"varint,3,opt,name=image_type,json=imageType,proto3,enum=protobuf.ImageType" json:"image_type,omitempty"`
	// encryption_keys is a list of encrypted keys that can be used to decrypted an encrypted payload
	EncryptionKeys [][]byte `protobuf:"bytes,4,rep,name=encryption_keys,json=encryptionKeys,proto3" json:"encryption_keys,omitempty"`
	// encrypted signals the encryption state of the payload, default is false.
	Encrypted            bool     `protobuf:"varint,5,opt,name=encrypted,proto3" json:"encrypted,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IdentityImage) Reset()         { *m = IdentityImage{} }
func (m *IdentityImage) String() string { return proto.CompactTextString(m) }
func (*IdentityImage) ProtoMessage()    {}
func (*IdentityImage) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a652489000a5879, []int{1}
}

func (m *IdentityImage) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IdentityImage.Unmarshal(m, b)
}
func (m *IdentityImage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IdentityImage.Marshal(b, m, deterministic)
}
func (m *IdentityImage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IdentityImage.Merge(m, src)
}
func (m *IdentityImage) XXX_Size() int {
	return xxx_messageInfo_IdentityImage.Size(m)
}
func (m *IdentityImage) XXX_DiscardUnknown() {
	xxx_messageInfo_IdentityImage.DiscardUnknown(m)
}

var xxx_messageInfo_IdentityImage proto.InternalMessageInfo

func (m *IdentityImage) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *IdentityImage) GetSourceType() IdentityImage_SourceType {
	if m != nil {
		return m.SourceType
	}
	return IdentityImage_UNKNOWN_SOURCE_TYPE
}

func (m *IdentityImage) GetImageType() ImageType {
	if m != nil {
		return m.ImageType
	}
	return ImageType_UNKNOWN_IMAGE_TYPE
}

func (m *IdentityImage) GetEncryptionKeys() [][]byte {
	if m != nil {
		return m.EncryptionKeys
	}
	return nil
}

func (m *IdentityImage) GetEncrypted() bool {
	if m != nil {
		return m.Encrypted
	}
	return false
}

// SocialLinks represents social link assosiated with given chat identity (personal/community)
type SocialLink struct {
	Text                 string   `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty"`
	Url                  string   `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SocialLink) Reset()         { *m = SocialLink{} }
func (m *SocialLink) String() string { return proto.CompactTextString(m) }
func (*SocialLink) ProtoMessage()    {}
func (*SocialLink) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a652489000a5879, []int{2}
}

func (m *SocialLink) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SocialLink.Unmarshal(m, b)
}
func (m *SocialLink) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SocialLink.Marshal(b, m, deterministic)
}
func (m *SocialLink) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SocialLink.Merge(m, src)
}
func (m *SocialLink) XXX_Size() int {
	return xxx_messageInfo_SocialLink.Size(m)
}
func (m *SocialLink) XXX_DiscardUnknown() {
	xxx_messageInfo_SocialLink.DiscardUnknown(m)
}

var xxx_messageInfo_SocialLink proto.InternalMessageInfo

func (m *SocialLink) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *SocialLink) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func init() {
	proto.RegisterEnum("protobuf.IdentityImage_SourceType", IdentityImage_SourceType_name, IdentityImage_SourceType_value)
	proto.RegisterType((*ChatIdentity)(nil), "protobuf.ChatIdentity")
	proto.RegisterMapType((map[string]*IdentityImage)(nil), "protobuf.ChatIdentity.ImagesEntry")
	proto.RegisterType((*IdentityImage)(nil), "protobuf.IdentityImage")
	proto.RegisterType((*SocialLink)(nil), "protobuf.SocialLink")
}

func init() {
	proto.RegisterFile("chat_identity.proto", fileDescriptor_7a652489000a5879)
}

var fileDescriptor_7a652489000a5879 = []byte{
	// 520 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x54, 0x52, 0x4f, 0x6f, 0xda, 0x4e,
	0x10, 0xfd, 0x19, 0x13, 0xfe, 0x8c, 0x81, 0xa0, 0x25, 0x3f, 0xe1, 0x46, 0x3d, 0xb8, 0x5c, 0xca,
	0xa5, 0xae, 0x44, 0xa5, 0xb6, 0x4a, 0x4f, 0x2e, 0xa5, 0x52, 0x94, 0x14, 0xa2, 0x85, 0x34, 0x4a,
	0x2f, 0xab, 0x8d, 0xd9, 0x24, 0x5b, 0xfc, 0x4f, 0xde, 0xa5, 0xaa, 0x3f, 0x56, 0xbe, 0x61, 0xe5,
	0xb1, 0x1d, 0x93, 0x93, 0xdf, 0xbc, 0x37, 0xfb, 0x76, 0x76, 0x9e, 0x61, 0xe4, 0x3f, 0x72, 0xcd,
	0xe4, 0x56, 0x44, 0x5a, 0xea, 0xcc, 0x4d, 0xd2, 0x58, 0xc7, 0xa4, 0x83, 0x9f, 0xbb, 0xfd, 0xfd,
	0xa9, 0x25, 0xa2, 0x7d, 0xa8, 0x0a, 0x7a, 0xf2, 0x64, 0x42, 0x6f, 0xfe, 0xc8, 0xf5, 0x79, 0xd9,
	0x4d, 0x4e, 0xe0, 0xc8, 0x0f, 0x62, 0x7f, 0x67, 0x1b, 0x8e, 0x31, 0x6d, 0xd2, 0xa2, 0x20, 0xaf,
	0xa0, 0x23, 0x22, 0xc5, 0x22, 0x1e, 0x0a, 0xbb, 0xe1, 0x18, 0xd3, 0x2e, 0x6d, 0x8b, 0x48, 0x2d,
	0x79, 0x28, 0xc8, 0x19, 0xb4, 0x64, 0xc8, 0x1f, 0x84, 0xb2, 0x4d, 0xc7, 0x9c, 0x5a, 0xb3, 0x89,
	0x5b, 0xdd, 0xe4, 0x1e, 0x1a, 0xbb, 0xe7, 0xd8, 0xb4, 0x88, 0x74, 0x9a, 0xd1, 0xf2, 0x04, 0x79,
	0x03, 0xbd, 0xad, 0x54, 0x49, 0xc0, 0xb3, 0xc2, 0xba, 0x89, 0xd6, 0x56, 0xc9, 0xa1, 0xbd, 0x03,
	0xd6, 0x56, 0x28, 0x3f, 0x95, 0x89, 0x96, 0x71, 0x64, 0x1f, 0x95, 0x1d, 0x35, 0x85, 0x13, 0xc7,
	0x41, 0x9c, 0xda, 0x2d, 0xd4, 0x8a, 0x22, 0x67, 0x45, 0x18, 0xff, 0x96, 0x76, 0xbb, 0x60, 0xb1,
	0x20, 0x9f, 0xa0, 0xa7, 0x62, 0x5f, 0xf2, 0x80, 0x05, 0x32, 0xda, 0x29, 0xbb, 0x83, 0x23, 0x9f,
	0xd4, 0x23, 0xaf, 0x51, 0xbd, 0x94, 0xd1, 0x8e, 0x5a, 0xea, 0x19, 0x2b, 0xf2, 0x11, 0xc6, 0xf7,
	0x32, 0x55, 0x9a, 0x85, 0x42, 0x29, 0xfe, 0x20, 0x98, 0x96, 0xa1, 0x50, 0x9a, 0x87, 0x89, 0xdd,
	0x75, 0x8c, 0x69, 0x9f, 0xfe, 0x8f, 0xf2, 0x8f, 0x42, 0xdd, 0x54, 0xe2, 0x29, 0x05, 0xeb, 0xe0,
	0xe1, 0x64, 0x08, 0xe6, 0x4e, 0x64, 0xb8, 0xdb, 0x2e, 0xcd, 0x21, 0x79, 0x07, 0x47, 0x7f, 0x78,
	0xb0, 0x2f, 0xd6, 0x6a, 0xcd, 0xc6, 0xf5, 0x28, 0xd5, 0xe6, 0xf0, 0x3c, 0x2d, 0xba, 0xce, 0x1a,
	0x9f, 0x8d, 0xc9, 0x53, 0x03, 0xfa, 0x2f, 0x44, 0x62, 0x43, 0x3b, 0xe1, 0x59, 0x10, 0xf3, 0x2d,
	0x5a, 0xf7, 0x68, 0x55, 0x92, 0x39, 0x58, 0x2a, 0xde, 0xa7, 0xbe, 0x60, 0x3a, 0x4b, 0x8a, 0x4b,
	0x06, 0x87, 0x11, 0xbd, 0xf0, 0x71, 0xd7, 0xd8, 0xba, 0xc9, 0x12, 0x41, 0x41, 0x3d, 0x63, 0x32,
	0x03, 0xc0, 0xc0, 0x0a, 0x0f, 0x13, 0x3d, 0x46, 0x07, 0x1e, 0xb9, 0x86, 0x87, 0xba, 0xb2, 0x82,
	0xe4, 0x2d, 0x1c, 0x8b, 0xc8, 0x4f, 0x33, 0xcc, 0x88, 0xed, 0x44, 0xa6, 0xec, 0xa6, 0x63, 0x4e,
	0x7b, 0x74, 0x50, 0xd3, 0x17, 0x22, 0x53, 0xe4, 0x35, 0x74, 0x4b, 0x46, 0x6c, 0x31, 0xde, 0x0e,
	0xad, 0x89, 0xc9, 0x77, 0x80, 0x7a, 0x28, 0x32, 0x86, 0xd1, 0xf5, 0xf2, 0x62, 0xb9, 0xba, 0x59,
	0xb2, 0xf5, 0xea, 0x9a, 0xce, 0x17, 0x6c, 0x73, 0x7b, 0xb5, 0x18, 0xfe, 0x47, 0x8e, 0xc1, 0xa2,
	0xde, 0x0d, 0xbb, 0xf2, 0x6e, 0x2f, 0x57, 0xde, 0xb7, 0xa1, 0x41, 0x06, 0x00, 0x8b, 0xe5, 0x9a,
	0x79, 0x3f, 0xbd, 0x8d, 0x47, 0x87, 0x8d, 0xc9, 0x2c, 0xf7, 0xa9, 0xe2, 0x24, 0x04, 0x9a, 0x5a,
	0xfc, 0xd5, 0x65, 0x0e, 0x88, 0xf3, 0x68, 0xf6, 0x69, 0x50, 0xfe, 0xdd, 0x39, 0xfc, 0xda, 0xff,
	0x65, 0xb9, 0xef, 0xbf, 0x54, 0xcf, 0xbc, 0x6b, 0x21, 0xfa, 0xf0, 0x2f, 0x00, 0x00, 0xff, 0xff,
	0x4e, 0xae, 0x6d, 0x0e, 0x5f, 0x03, 0x00, 0x00,
}
