// Code generated by MockGen. DO NOT EDIT.
// Source: services/wallet/thirdparty/collectible_types.go

// Package mock_thirdparty is a generated GoMock package.
package mock_thirdparty

import (
	context "context"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"

	common "github.com/ethereum/go-ethereum/common"
	common0 "github.com/status-im/status-go/services/wallet/common"
	thirdparty "github.com/status-im/status-go/services/wallet/thirdparty"
)

// MockCollectibleProvider is a mock of CollectibleProvider interface.
type MockCollectibleProvider struct {
	ctrl     *gomock.Controller
	recorder *MockCollectibleProviderMockRecorder
}

// MockCollectibleProviderMockRecorder is the mock recorder for MockCollectibleProvider.
type MockCollectibleProviderMockRecorder struct {
	mock *MockCollectibleProvider
}

// NewMockCollectibleProvider creates a new mock instance.
func NewMockCollectibleProvider(ctrl *gomock.Controller) *MockCollectibleProvider {
	mock := &MockCollectibleProvider{ctrl: ctrl}
	mock.recorder = &MockCollectibleProviderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCollectibleProvider) EXPECT() *MockCollectibleProviderMockRecorder {
	return m.recorder
}

// ID mocks base method.
func (m *MockCollectibleProvider) ID() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ID")
	ret0, _ := ret[0].(string)
	return ret0
}

// ID indicates an expected call of ID.
func (mr *MockCollectibleProviderMockRecorder) ID() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ID", reflect.TypeOf((*MockCollectibleProvider)(nil).ID))
}

// IsChainSupported mocks base method.
func (m *MockCollectibleProvider) IsChainSupported(chainID common0.ChainID) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsChainSupported", chainID)
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsChainSupported indicates an expected call of IsChainSupported.
func (mr *MockCollectibleProviderMockRecorder) IsChainSupported(chainID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsChainSupported", reflect.TypeOf((*MockCollectibleProvider)(nil).IsChainSupported), chainID)
}

// IsConnected mocks base method.
func (m *MockCollectibleProvider) IsConnected() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsConnected")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsConnected indicates an expected call of IsConnected.
func (mr *MockCollectibleProviderMockRecorder) IsConnected() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsConnected", reflect.TypeOf((*MockCollectibleProvider)(nil).IsConnected))
}

// MockCollectibleContractOwnershipProvider is a mock of CollectibleContractOwnershipProvider interface.
type MockCollectibleContractOwnershipProvider struct {
	ctrl     *gomock.Controller
	recorder *MockCollectibleContractOwnershipProviderMockRecorder
}

// MockCollectibleContractOwnershipProviderMockRecorder is the mock recorder for MockCollectibleContractOwnershipProvider.
type MockCollectibleContractOwnershipProviderMockRecorder struct {
	mock *MockCollectibleContractOwnershipProvider
}

// NewMockCollectibleContractOwnershipProvider creates a new mock instance.
func NewMockCollectibleContractOwnershipProvider(ctrl *gomock.Controller) *MockCollectibleContractOwnershipProvider {
	mock := &MockCollectibleContractOwnershipProvider{ctrl: ctrl}
	mock.recorder = &MockCollectibleContractOwnershipProviderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCollectibleContractOwnershipProvider) EXPECT() *MockCollectibleContractOwnershipProviderMockRecorder {
	return m.recorder
}

// FetchCollectibleOwnersByContractAddress mocks base method.
func (m *MockCollectibleContractOwnershipProvider) FetchCollectibleOwnersByContractAddress(ctx context.Context, chainID common0.ChainID, contractAddress common.Address) (*thirdparty.CollectibleContractOwnership, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FetchCollectibleOwnersByContractAddress", ctx, chainID, contractAddress)
	ret0, _ := ret[0].(*thirdparty.CollectibleContractOwnership)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FetchCollectibleOwnersByContractAddress indicates an expected call of FetchCollectibleOwnersByContractAddress.
func (mr *MockCollectibleContractOwnershipProviderMockRecorder) FetchCollectibleOwnersByContractAddress(ctx, chainID, contractAddress interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FetchCollectibleOwnersByContractAddress", reflect.TypeOf((*MockCollectibleContractOwnershipProvider)(nil).FetchCollectibleOwnersByContractAddress), ctx, chainID, contractAddress)
}

// ID mocks base method.
func (m *MockCollectibleContractOwnershipProvider) ID() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ID")
	ret0, _ := ret[0].(string)
	return ret0
}

// ID indicates an expected call of ID.
func (mr *MockCollectibleContractOwnershipProviderMockRecorder) ID() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ID", reflect.TypeOf((*MockCollectibleContractOwnershipProvider)(nil).ID))
}

// IsChainSupported mocks base method.
func (m *MockCollectibleContractOwnershipProvider) IsChainSupported(chainID common0.ChainID) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsChainSupported", chainID)
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsChainSupported indicates an expected call of IsChainSupported.
func (mr *MockCollectibleContractOwnershipProviderMockRecorder) IsChainSupported(chainID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsChainSupported", reflect.TypeOf((*MockCollectibleContractOwnershipProvider)(nil).IsChainSupported), chainID)
}

// IsConnected mocks base method.
func (m *MockCollectibleContractOwnershipProvider) IsConnected() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsConnected")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsConnected indicates an expected call of IsConnected.
func (mr *MockCollectibleContractOwnershipProviderMockRecorder) IsConnected() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsConnected", reflect.TypeOf((*MockCollectibleContractOwnershipProvider)(nil).IsConnected))
}

// MockCollectibleAccountOwnershipProvider is a mock of CollectibleAccountOwnershipProvider interface.
type MockCollectibleAccountOwnershipProvider struct {
	ctrl     *gomock.Controller
	recorder *MockCollectibleAccountOwnershipProviderMockRecorder
}

// MockCollectibleAccountOwnershipProviderMockRecorder is the mock recorder for MockCollectibleAccountOwnershipProvider.
type MockCollectibleAccountOwnershipProviderMockRecorder struct {
	mock *MockCollectibleAccountOwnershipProvider
}

// NewMockCollectibleAccountOwnershipProvider creates a new mock instance.
func NewMockCollectibleAccountOwnershipProvider(ctrl *gomock.Controller) *MockCollectibleAccountOwnershipProvider {
	mock := &MockCollectibleAccountOwnershipProvider{ctrl: ctrl}
	mock.recorder = &MockCollectibleAccountOwnershipProviderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCollectibleAccountOwnershipProvider) EXPECT() *MockCollectibleAccountOwnershipProviderMockRecorder {
	return m.recorder
}

// FetchAllAssetsByOwner mocks base method.
func (m *MockCollectibleAccountOwnershipProvider) FetchAllAssetsByOwner(ctx context.Context, chainID common0.ChainID, owner common.Address, cursor string, limit int) (*thirdparty.FullCollectibleDataContainer, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FetchAllAssetsByOwner", ctx, chainID, owner, cursor, limit)
	ret0, _ := ret[0].(*thirdparty.FullCollectibleDataContainer)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FetchAllAssetsByOwner indicates an expected call of FetchAllAssetsByOwner.
func (mr *MockCollectibleAccountOwnershipProviderMockRecorder) FetchAllAssetsByOwner(ctx, chainID, owner, cursor, limit interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FetchAllAssetsByOwner", reflect.TypeOf((*MockCollectibleAccountOwnershipProvider)(nil).FetchAllAssetsByOwner), ctx, chainID, owner, cursor, limit)
}

// FetchAllAssetsByOwnerAndContractAddress mocks base method.
func (m *MockCollectibleAccountOwnershipProvider) FetchAllAssetsByOwnerAndContractAddress(ctx context.Context, chainID common0.ChainID, owner common.Address, contractAddresses []common.Address, cursor string, limit int) (*thirdparty.FullCollectibleDataContainer, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FetchAllAssetsByOwnerAndContractAddress", ctx, chainID, owner, contractAddresses, cursor, limit)
	ret0, _ := ret[0].(*thirdparty.FullCollectibleDataContainer)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FetchAllAssetsByOwnerAndContractAddress indicates an expected call of FetchAllAssetsByOwnerAndContractAddress.
func (mr *MockCollectibleAccountOwnershipProviderMockRecorder) FetchAllAssetsByOwnerAndContractAddress(ctx, chainID, owner, contractAddresses, cursor, limit interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FetchAllAssetsByOwnerAndContractAddress", reflect.TypeOf((*MockCollectibleAccountOwnershipProvider)(nil).FetchAllAssetsByOwnerAndContractAddress), ctx, chainID, owner, contractAddresses, cursor, limit)
}

// ID mocks base method.
func (m *MockCollectibleAccountOwnershipProvider) ID() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ID")
	ret0, _ := ret[0].(string)
	return ret0
}

// ID indicates an expected call of ID.
func (mr *MockCollectibleAccountOwnershipProviderMockRecorder) ID() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ID", reflect.TypeOf((*MockCollectibleAccountOwnershipProvider)(nil).ID))
}

// IsChainSupported mocks base method.
func (m *MockCollectibleAccountOwnershipProvider) IsChainSupported(chainID common0.ChainID) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsChainSupported", chainID)
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsChainSupported indicates an expected call of IsChainSupported.
func (mr *MockCollectibleAccountOwnershipProviderMockRecorder) IsChainSupported(chainID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsChainSupported", reflect.TypeOf((*MockCollectibleAccountOwnershipProvider)(nil).IsChainSupported), chainID)
}

// IsConnected mocks base method.
func (m *MockCollectibleAccountOwnershipProvider) IsConnected() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsConnected")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsConnected indicates an expected call of IsConnected.
func (mr *MockCollectibleAccountOwnershipProviderMockRecorder) IsConnected() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsConnected", reflect.TypeOf((*MockCollectibleAccountOwnershipProvider)(nil).IsConnected))
}

// MockCollectibleDataProvider is a mock of CollectibleDataProvider interface.
type MockCollectibleDataProvider struct {
	ctrl     *gomock.Controller
	recorder *MockCollectibleDataProviderMockRecorder
}

// MockCollectibleDataProviderMockRecorder is the mock recorder for MockCollectibleDataProvider.
type MockCollectibleDataProviderMockRecorder struct {
	mock *MockCollectibleDataProvider
}

// NewMockCollectibleDataProvider creates a new mock instance.
func NewMockCollectibleDataProvider(ctrl *gomock.Controller) *MockCollectibleDataProvider {
	mock := &MockCollectibleDataProvider{ctrl: ctrl}
	mock.recorder = &MockCollectibleDataProviderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCollectibleDataProvider) EXPECT() *MockCollectibleDataProviderMockRecorder {
	return m.recorder
}

// FetchAssetsByCollectibleUniqueID mocks base method.
func (m *MockCollectibleDataProvider) FetchAssetsByCollectibleUniqueID(ctx context.Context, uniqueIDs []thirdparty.CollectibleUniqueID) ([]thirdparty.FullCollectibleData, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FetchAssetsByCollectibleUniqueID", ctx, uniqueIDs)
	ret0, _ := ret[0].([]thirdparty.FullCollectibleData)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FetchAssetsByCollectibleUniqueID indicates an expected call of FetchAssetsByCollectibleUniqueID.
func (mr *MockCollectibleDataProviderMockRecorder) FetchAssetsByCollectibleUniqueID(ctx, uniqueIDs interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FetchAssetsByCollectibleUniqueID", reflect.TypeOf((*MockCollectibleDataProvider)(nil).FetchAssetsByCollectibleUniqueID), ctx, uniqueIDs)
}

// FetchCollectionSocials mocks base method.
func (m *MockCollectibleDataProvider) FetchCollectionSocials(ctx context.Context, contractID thirdparty.ContractID) (*thirdparty.CollectionSocials, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FetchCollectionSocials", ctx, contractID)
	ret0, _ := ret[0].(*thirdparty.CollectionSocials)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FetchCollectionSocials indicates an expected call of FetchCollectionSocials.
func (mr *MockCollectibleDataProviderMockRecorder) FetchCollectionSocials(ctx, contractID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FetchCollectionSocials", reflect.TypeOf((*MockCollectibleDataProvider)(nil).FetchCollectionSocials), ctx, contractID)
}

// ID mocks base method.
func (m *MockCollectibleDataProvider) ID() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ID")
	ret0, _ := ret[0].(string)
	return ret0
}

// ID indicates an expected call of ID.
func (mr *MockCollectibleDataProviderMockRecorder) ID() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ID", reflect.TypeOf((*MockCollectibleDataProvider)(nil).ID))
}

// IsChainSupported mocks base method.
func (m *MockCollectibleDataProvider) IsChainSupported(chainID common0.ChainID) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsChainSupported", chainID)
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsChainSupported indicates an expected call of IsChainSupported.
func (mr *MockCollectibleDataProviderMockRecorder) IsChainSupported(chainID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsChainSupported", reflect.TypeOf((*MockCollectibleDataProvider)(nil).IsChainSupported), chainID)
}

// IsConnected mocks base method.
func (m *MockCollectibleDataProvider) IsConnected() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsConnected")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsConnected indicates an expected call of IsConnected.
func (mr *MockCollectibleDataProviderMockRecorder) IsConnected() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsConnected", reflect.TypeOf((*MockCollectibleDataProvider)(nil).IsConnected))
}

// MockCollectionDataProvider is a mock of CollectionDataProvider interface.
type MockCollectionDataProvider struct {
	ctrl     *gomock.Controller
	recorder *MockCollectionDataProviderMockRecorder
}

// MockCollectionDataProviderMockRecorder is the mock recorder for MockCollectionDataProvider.
type MockCollectionDataProviderMockRecorder struct {
	mock *MockCollectionDataProvider
}

// NewMockCollectionDataProvider creates a new mock instance.
func NewMockCollectionDataProvider(ctrl *gomock.Controller) *MockCollectionDataProvider {
	mock := &MockCollectionDataProvider{ctrl: ctrl}
	mock.recorder = &MockCollectionDataProviderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCollectionDataProvider) EXPECT() *MockCollectionDataProviderMockRecorder {
	return m.recorder
}

// FetchCollectionsDataByContractID mocks base method.
func (m *MockCollectionDataProvider) FetchCollectionsDataByContractID(ctx context.Context, ids []thirdparty.ContractID) ([]thirdparty.CollectionData, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FetchCollectionsDataByContractID", ctx, ids)
	ret0, _ := ret[0].([]thirdparty.CollectionData)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FetchCollectionsDataByContractID indicates an expected call of FetchCollectionsDataByContractID.
func (mr *MockCollectionDataProviderMockRecorder) FetchCollectionsDataByContractID(ctx, ids interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FetchCollectionsDataByContractID", reflect.TypeOf((*MockCollectionDataProvider)(nil).FetchCollectionsDataByContractID), ctx, ids)
}

// ID mocks base method.
func (m *MockCollectionDataProvider) ID() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ID")
	ret0, _ := ret[0].(string)
	return ret0
}

// ID indicates an expected call of ID.
func (mr *MockCollectionDataProviderMockRecorder) ID() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ID", reflect.TypeOf((*MockCollectionDataProvider)(nil).ID))
}

// IsChainSupported mocks base method.
func (m *MockCollectionDataProvider) IsChainSupported(chainID common0.ChainID) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsChainSupported", chainID)
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsChainSupported indicates an expected call of IsChainSupported.
func (mr *MockCollectionDataProviderMockRecorder) IsChainSupported(chainID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsChainSupported", reflect.TypeOf((*MockCollectionDataProvider)(nil).IsChainSupported), chainID)
}

// IsConnected mocks base method.
func (m *MockCollectionDataProvider) IsConnected() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsConnected")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsConnected indicates an expected call of IsConnected.
func (mr *MockCollectionDataProviderMockRecorder) IsConnected() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsConnected", reflect.TypeOf((*MockCollectionDataProvider)(nil).IsConnected))
}

// MockCollectibleSearchProvider is a mock of CollectibleSearchProvider interface.
type MockCollectibleSearchProvider struct {
	ctrl     *gomock.Controller
	recorder *MockCollectibleSearchProviderMockRecorder
}

// MockCollectibleSearchProviderMockRecorder is the mock recorder for MockCollectibleSearchProvider.
type MockCollectibleSearchProviderMockRecorder struct {
	mock *MockCollectibleSearchProvider
}

// NewMockCollectibleSearchProvider creates a new mock instance.
func NewMockCollectibleSearchProvider(ctrl *gomock.Controller) *MockCollectibleSearchProvider {
	mock := &MockCollectibleSearchProvider{ctrl: ctrl}
	mock.recorder = &MockCollectibleSearchProviderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCollectibleSearchProvider) EXPECT() *MockCollectibleSearchProviderMockRecorder {
	return m.recorder
}

// ID mocks base method.
func (m *MockCollectibleSearchProvider) ID() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ID")
	ret0, _ := ret[0].(string)
	return ret0
}

// ID indicates an expected call of ID.
func (mr *MockCollectibleSearchProviderMockRecorder) ID() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ID", reflect.TypeOf((*MockCollectibleSearchProvider)(nil).ID))
}

// IsChainSupported mocks base method.
func (m *MockCollectibleSearchProvider) IsChainSupported(chainID common0.ChainID) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsChainSupported", chainID)
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsChainSupported indicates an expected call of IsChainSupported.
func (mr *MockCollectibleSearchProviderMockRecorder) IsChainSupported(chainID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsChainSupported", reflect.TypeOf((*MockCollectibleSearchProvider)(nil).IsChainSupported), chainID)
}

// IsConnected mocks base method.
func (m *MockCollectibleSearchProvider) IsConnected() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsConnected")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsConnected indicates an expected call of IsConnected.
func (mr *MockCollectibleSearchProviderMockRecorder) IsConnected() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsConnected", reflect.TypeOf((*MockCollectibleSearchProvider)(nil).IsConnected))
}

// SearchCollectibles mocks base method.
func (m *MockCollectibleSearchProvider) SearchCollectibles(ctx context.Context, chainID common0.ChainID, collections []common.Address, text, cursor string, limit int) (*thirdparty.FullCollectibleDataContainer, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SearchCollectibles", ctx, chainID, collections, text, cursor, limit)
	ret0, _ := ret[0].(*thirdparty.FullCollectibleDataContainer)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SearchCollectibles indicates an expected call of SearchCollectibles.
func (mr *MockCollectibleSearchProviderMockRecorder) SearchCollectibles(ctx, chainID, collections, text, cursor, limit interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SearchCollectibles", reflect.TypeOf((*MockCollectibleSearchProvider)(nil).SearchCollectibles), ctx, chainID, collections, text, cursor, limit)
}

// SearchCollections mocks base method.
func (m *MockCollectibleSearchProvider) SearchCollections(ctx context.Context, chainID common0.ChainID, text, cursor string, limit int) (*thirdparty.CollectionDataContainer, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SearchCollections", ctx, chainID, text, cursor, limit)
	ret0, _ := ret[0].(*thirdparty.CollectionDataContainer)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SearchCollections indicates an expected call of SearchCollections.
func (mr *MockCollectibleSearchProviderMockRecorder) SearchCollections(ctx, chainID, text, cursor, limit interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SearchCollections", reflect.TypeOf((*MockCollectibleSearchProvider)(nil).SearchCollections), ctx, chainID, text, cursor, limit)
}
