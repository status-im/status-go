// Code generated by MockGen. DO NOT EDIT.
// Source: services/wallet/router/router.go

// Package router is a generated GoMock package.
package router

import (
	context "context"
	big "math/big"
	reflect "reflect"

	common "github.com/ethereum/go-ethereum/common"
	gomock "github.com/golang/mock/gomock"
	params "github.com/status-im/status-go/params"
	pathprocessor "github.com/status-im/status-go/services/wallet/router/pathprocessor"
	token "github.com/status-im/status-go/services/wallet/token"
)

// MockEstimator is a mock of Estimator interface.
type MockEstimator struct {
	ctrl     *gomock.Controller
	recorder *MockEstimatorMockRecorder
}

// MockEstimatorMockRecorder is the mock recorder for MockEstimator.
type MockEstimatorMockRecorder struct {
	mock *MockEstimator
}

// NewMockEstimator creates a new mock instance.
func NewMockEstimator(ctrl *gomock.Controller) *MockEstimator {
	mock := &MockEstimator{ctrl: ctrl}
	mock.recorder = &MockEstimatorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockEstimator) EXPECT() *MockEstimatorMockRecorder {
	return m.recorder
}

// Estimate mocks base method.
func (m *MockEstimator) Estimate(ctx context.Context, chainID uint64, txInputData []byte, needL1Fee bool, gasFeeMode GasFeeMode) (*SuggestedFees, uint64, TransactionEstimation, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Estimate", ctx, chainID, txInputData, needL1Fee, gasFeeMode)
	ret0, _ := ret[0].(*SuggestedFees)
	ret1, _ := ret[1].(uint64)
	ret2, _ := ret[2].(TransactionEstimation)
	ret3, _ := ret[3].(error)
	return ret0, ret1, ret2, ret3
}

// Estimate indicates an expected call of Estimate.
func (mr *MockEstimatorMockRecorder) Estimate(ctx, chainID, txInputData, needL1Fee, gasFeeMode interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Estimate", reflect.TypeOf((*MockEstimator)(nil).Estimate), ctx, chainID, txInputData, needL1Fee, gasFeeMode)
}

// MockCandidateResolver is a mock of CandidateResolver interface.
type MockCandidateResolver struct {
	ctrl     *gomock.Controller
	recorder *MockCandidateResolverMockRecorder
}

// MockCandidateResolverMockRecorder is the mock recorder for MockCandidateResolver.
type MockCandidateResolverMockRecorder struct {
	mock *MockCandidateResolver
}

// NewMockCandidateResolver creates a new mock instance.
func NewMockCandidateResolver(ctrl *gomock.Controller) *MockCandidateResolver {
	mock := &MockCandidateResolver{ctrl: ctrl}
	mock.recorder = &MockCandidateResolverMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCandidateResolver) EXPECT() *MockCandidateResolverMockRecorder {
	return m.recorder
}

// requireApproval mocks base method.
func (m *MockCandidateResolver) requireApproval(ctx context.Context, sendType SendType, approvalContractAddress *common.Address, params pathprocessor.ProcessorInputParams) (bool, *big.Int, uint64, uint64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "requireApproval", ctx, sendType, approvalContractAddress, params)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(*big.Int)
	ret2, _ := ret[2].(uint64)
	ret3, _ := ret[3].(uint64)
	ret4, _ := ret[4].(error)
	return ret0, ret1, ret2, ret3, ret4
}

// requireApproval indicates an expected call of requireApproval.
func (mr *MockCandidateResolverMockRecorder) requireApproval(ctx, sendType, approvalContractAddress, params interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "requireApproval", reflect.TypeOf((*MockCandidateResolver)(nil).requireApproval), ctx, sendType, approvalContractAddress, params)
}

// resolveCandidatesForProcessor mocks base method.
func (m *MockCandidateResolver) resolveCandidatesForProcessor(ctx context.Context, input *RouteInputParams, network *params.Network, token, toToken *token.Token, amountToSend *big.Int, amountLocked bool, pProcessor pathprocessor.PathProcessor, networks []*params.Network) []*PathV2 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "resolveCandidatesForProcessor", ctx, input, network, token, toToken, amountToSend, amountLocked, pProcessor, networks)
	ret0, _ := ret[0].([]*PathV2)
	return ret0
}

// resolveCandidatesForProcessor indicates an expected call of resolveCandidatesForProcessor.
func (mr *MockCandidateResolverMockRecorder) resolveCandidatesForProcessor(ctx, input, network, token, toToken, amountToSend, amountLocked, pProcessor, networks interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "resolveCandidatesForProcessor", reflect.TypeOf((*MockCandidateResolver)(nil).resolveCandidatesForProcessor), ctx, input, network, token, toToken, amountToSend, amountLocked, pProcessor, networks)
}
