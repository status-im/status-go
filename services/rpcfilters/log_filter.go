package rpcfilters

import (
	"errors"
	"math/big"
	"strconv"

	"github.com/ethereum/go-ethereum/common"
)

var (
	//ErrInvalidFilterCriteria - error filter criteria is invalid
	ErrInvalidFilterCriteria = errors.New("filter criteria is invalid")
)

// LogFilter is part of the eth_newfilter implementation.
// It gets all the logs according to the criteria
type LogFilter struct {
	blockProvider  *blockProviderRPC
	filterCriteria *FilterCriteria
}

// FilterCriteria contains options for contract log filtering.
type FilterCriteria struct {
	FromBlock *big.Int         // beginning of the queried range, nil means genesis block
	ToBlock   *big.Int         // end of the range, nil means latest block
	Addresses []common.Address // restricts matches to events created by specific contracts

	// The Topic list restricts matches to particular event topics. Each event has a list
	// of topics. Topics matches a prefix of that list. An empty element slice matches any
	// topic. Non-empty elements represent an alternative that matches any of the
	// contained topics.
	//
	// Examples:
	// {} or nil          matches any topic list
	// {{A}}              matches topic A in first position
	// {{}, {B}}          matches any topic in first position, B in second position
	// {{A}, {B}}         matches topic A in first position, B in second position
	// {{A, B}}, {C, D}}  matches topic (A OR B) in first position, (C OR D) in second position
	Topics [][]common.Hash
}

// NewLogFilter returns a new LogFilter that will yield all the logs that fit
// the criteria when called with .Log()
func NewLogFilter(provider *blockProviderRPC, crit *FilterCriteria) (*LogFilter, error) {
	f := LogFilter{
		blockProvider:  provider,
		filterCriteria: crit,
	}

	// Validate FilterCriteria
	latestBlock, err := f.blockProvider.GetLatestBlock()
	if err != nil {
		return nil, err
	}
	latestBlockNumber, err := strconv.ParseInt(string(latestBlock.NumberBytes), 0, 64)
	if err != nil {
		return nil, err
	}
	if crit.FromBlock == nil {
		crit.FromBlock = big.NewInt(latestBlockNumber)
	}
	if crit.ToBlock == nil {
		crit.ToBlock = big.NewInt(latestBlockNumber)
	}
	if diff := crit.FromBlock.Cmp(crit.ToBlock); diff == 1 {
		return nil, ErrInvalidFilterCriteria
	}
	return &f, nil
}

// Log actually flushes all the Logs corresponding to the criteria into the channel
func (f *LogFilter) Log() {
	// TODO (seb): implement so that it adds all necessary logs to the channel
	// This  implementation will depend on whether we are waiting for the latest block
	// or always returning logs related to already existing blocks

}

// Subscribe returns a channel that will receive all the logs generated by
// this filter
func (f *LogFilter) Subscribe() (int, chan common.Hash) {
	// TODO (seb): implement with a channel that has a type different from commmon.Hash (we need to pass in logs)
	return 0, nil
}

// Unsubscribe cancels the subscription and stops writing to the channel
func (f *LogFilter) Unsubscribe(id int) {
	// TODO (seb): implement
}
