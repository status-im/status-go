//nolint
// Code generated by generate_handlers.go. DO NOT EDIT.
// source: generate_handlers.go

package protocol

import (
        "errors"

	"github.com/golang/protobuf/proto"
	"go.uber.org/zap"

	"github.com/status-im/status-go/protocol/common"
	"github.com/status-im/status-go/protocol/protobuf"
	"github.com/status-im/status-go/protocol/transport"
	v1protocol "github.com/status-im/status-go/protocol/v1"
)

func (m *Messenger) dispatchToHandler(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter, fromArchive bool) error {
	switch msg.ApplicationLayer.Type {
	{{ range .}}
           case protobuf.ApplicationMetadataMessage_{{.EnumValue}}:
		return m.{{.MethodName}}(messageState, protoBytes, msg, filter{{ if .FromArchiveArg }}, fromArchive{{ end }})
        {{ end }}	
	}
	m.logger.Info("protobuf type not found", zap.String("type", string(msg.ApplicationLayer.Type)))
	return errors.New("protobuf type not found")
}

{{ range . }}
func (m *Messenger) {{.MethodName}}(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter{{ if .FromArchiveArg }}, fromArchive bool{{ end }}) error {
	m.logger.Info("handling {{ .ProtobufName}}")
	{{ if .SyncMessage }}
	if !common.IsPubKeyEqual(messageState.CurrentMessageState.PublicKey, &m.identity.PublicKey) {
		m.logger.Warn("not coming from us, ignoring")
		return nil
	}
	{{ end }}

	{{ if .ProcessRaw }}
	return m.Handle{{.ProtobufName}}(messageState, protoBytes, msg)
	{{ else }}
	p := &protobuf.{{.ProtobufName}}{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.Handle{{.ProtobufName}}(messageState, p, msg{{ if .FromArchiveArg }}, fromArchive {{ end }})
	{{ end }}
}

{{ end }}
