<html lang="en">
<head>
    <title>Whisper Notification Server Test</title>
    <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
    <script
            src="https://code.jquery.com/jquery-3.1.1.js"
            integrity="sha256-16cdPddA6VdVInumRGo6IbivbERE8p7CQR3HzTBuELA="
            crossorigin="anonymous"></script>
    <script type="text/javascript" src="http://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="./../scripts/bignumber.js"></script>
    <script type="text/javascript" src="./../scripts/web3.js"></script>

    <script type="text/javascript">
        var protocolKey = '0x040edb0d71a3dbe928e154fcb696ffbda359b153a90efc2b46f0043ce9f5dbe55b77b9328fd841a1db5273758624afadd5b39638d4c35b36b3a96e1a586c1b4c2a';
        var discoverServerTopic = '0x268302f3'; // DISCOVER_NOTIFICATION_SERVER
        var proposeServerTopic = '0x08e3d8c0'; // PROPOSE_NOTIFICATION_SERVER
        var acceptServerTopic = '0x04f7dea6'; // ACCEPT_NOTIFICATION_SERVER
        var ackClientSubscriptionTopic = '0x93dafe28'; // ACK_NOTIFICATION_SERVER_SUBSCRIPTION
        var sendNotificationTopic = '0x69915296'; // SEND_NOTIFICATION
        var newChatSessionTopic = '0x509579a2'; // NEW_CHAT_SESSION
        var ackNewChatSessionTopic = '0xd012aae8'; // ACK_NEW_CHAT_SESSION
        var newDeviceRegistrationTopic = '0x14621a51'; // NEW_DEVICE_REGISTRATION
        var ackDeviceRegistrationTopic = '0x424358d6'; // ACK_DEVICE_REGISTRATION
        var checkClientSessionTopic = '0x8745d931'; // CHECK_CLIENT_SESSION
        var confirmClientSessionTopic  = '0xd3202c5f'; // CONFIRM_CLIENT_SESSION
        var dropClientSessionTopic = '0x3a6656bb'; // DROP_CLIENT_SESSION

        // this will be used both by Device A and Device B
        var registerDevice = function (web3, identity, chatId, chatKey, deviceId) {
            console.log('chat session key: ', chatKey);

            // make sure that chat key is loaded
            var keyname = chatId + 'chatkey'; // there might be many chat keys
            web3.shh.deleteSymKey(keyname);
            web3.shh.addSymKey(keyname, chatKey);

            // before sending request, let's start waiting for response
            var filter = web3.shh.filter({
                to: identity,
                topics: [ackDeviceRegistrationTopic]
            });
            filter.watch(function (error, result) {
                if (!error) {
                    // response will be in JSON, e.g. {"server": "0xdeadbeef"}
                    var payload = JSON.parse(web3.toAscii(result.payload));
                    console.log("Device Registration ACK received: ", result, payload);

                    // no need to watch for the filter any more
                    filter.stopWatching();
                }
            });

            var err = web3.shh.post({
                from: identity,
                topics: [newDeviceRegistrationTopic],
                payload: '{"device": "' + deviceId + '"}',
                ttl: 20,
                keyname: keyname
            });
            if (err !== null) {
                console.log("message NOT sent")
            } else {
                console.log("message sent OK")
            }
        };

        var startDeviceA = function () {
            var web3 = new Web3();
            web3.setProvider(new web3.providers.HttpProvider('http://localhost:8645'));

            var sendDiscoveryRequest = function (identity) {
                // notification server discovery request is a signed (sent from us),
                // encrypted with Notification Protocol Asymmetric (Public) Key
                var err = web3.shh.post({
                    from: identity,
                    to: protocolKey,
                    topics: [discoverServerTopic],
                    ttl: 20
                });
                if (err !== null) {
                    console.log("message NOT sent")
                } else {
                    console.log("message sent OK")
                }
            };

            var sendAcceptServerRequest = function (identity, serverId) {
                // whenever we are ready to accept server, having a given serverId, we need
                // to notify it by sending signed (from us) and encrypted (using protocol key)
                // acceptance message.
                var err = web3.shh.post({
                    from: identity, // it is absolutely important to identify the client, or your acceptance will be dropped
                    to: protocolKey,
                    topics: [acceptServerTopic],
                    payload: '{"server": "' + serverId + '"}',
                    ttl: 20
                });
                if (err !== null) {
                    console.log("message NOT sent")
                } else {
                    console.log("message sent OK")
                }
            };

            var watchProposeServerResponses = function (identity) {
                // some notification servers will be able to serve, so they will send encrypted (to you)
                // message, with a PROPOSE_NOTIFICATION_SERVER topic (for which we wait)
                var filter = web3.shh.filter({
                    to: identity, // wait for anon. messages to ourselves
                    topics: [proposeServerTopic]
                });
                filter.watch(function (error, result) {
                    if (!error) {
                        console.log("Server proposal received: ", result);
                        // response will be in JSON, e.g. {"server": "0x81f34abd0df038e01a8f9c04bee7ce92925b7240e334dc8f2400dea7a2a6d829678be8b40e1d9b9988e25960552eafe2df7f928188e4143ba657a699519c438d"}
                        // which will give you serverId
                        var payload = JSON.parse(web3.toAscii(result.payload));
                        console.log(payload);

                        // no need to watch for the filter any more
                        filter.stopWatching();

                        // accept (in FIFO order) the server
                        // we need to make sure that only a single server is selected,
                        // as you will receive multiple proposals for different servers,
                        // and may accept more that one of those proposals (which will
                        // result in duplicate notifications)
                        sendAcceptServerRequest(identity, payload.server);
                    }
                });
            };

            var shareChatKey = function (chatId, chatKey) {
                console.log('chat session key: ', chatKey)
                // pre-defined test identity (it gets injected automatically by statusd)
                var deviceBIdentity = '0x04eedbaafd6adf4a9233a13e7b1c3c14461fffeba2e9054b8d456ce5f6ebeafadcbf3dce3716253fbc391277fa5a086b60b283daf61fb5b1f26895f456c2f31ae3';

                // it is up to you how you share secret among participants, here is sample
                var err = web3.shh.post({
                    from: identity,
                    to: deviceBIdentity,
                    topics: ["chatKeySharing"],
                    payload: '{"chat": "' + chatId + '", "key": "' + chatKey + '"}',
                    ttl: 20
                });
                if (err !== null) {
                    console.log("message NOT sent")
                } else {
                    console.log("message sent OK")
                }
            };

            var removeClientSession = function () {
                var checkClientSession = function (callback) {
                    // before sending request, let's start waiting for response
                    var filter = web3.shh.filter({
                        to: identity,
                        topics: [confirmClientSessionTopic]
                    });
                    filter.watch(function (error, result) {
                        if (!error) {
                            // response will be in JSON, e.g. {"server": "0xdeadbeef", "key": "0xdeadbeef"}
                            var payload = JSON.parse(web3.toAscii(result.payload));
                            console.log("Client session confirmation received: ", result, payload);

                            // no need to watch for the filter any more
                            filter.stopWatching();

                            callback(payload)
                        }
                    });

                    // send enquiry to all servers, to learn whether we have a client session with any of them
                    var err = web3.shh.post({
                        from: identity,
                        to: protocolKey,
                        topics: [checkClientSessionTopic],
                        ttl: 20
                    });
                    if (err !== null) {
                        console.log("message NOT sent")
                    } else {
                        console.log("message sent OK")
                    }
                };

                checkClientSession(function (payload) {
                    console.log("time to cleanup: ", payload.server);
                    console.log("session key: ", payload.key);

                    setTimeout(function () {
                        // notify server that you want to unsubscribe
                        var err = web3.shh.post({
                            from: identity,
                            to: protocolKey,
                            topics: [dropClientSessionTopic],
                            ttl: 20
                        });
                        if (err !== null) {
                            console.log("message NOT sent")
                        } else {
                            console.log("message sent OK")
                        }
                    }, 5000); // let's all other concurrent tasks to wrap up
                });
            };

            var createChatSession = function (subscriptionKey) {
                var chatId = '0xdeadbeef';

                // subscriptionKey is key shared by server that allows us to communicate with server privately
                var keyname = 'SUBSCRIPTION_KEY'; // you might want to be tad more creative
                web3.shh.deleteSymKey(keyname);
                web3.shh.addSymKey(keyname, subscriptionKey);

                console.log("subscription key: ", subscriptionKey);

                // before sending new chat request, let's start waiting for response
                var filter = web3.shh.filter({
                    to: identity,
                    topics: [ackNewChatSessionTopic]
                });
                filter.watch(function (error, result) {
                    if (!error) {
                        console.log("Chat Creation ACK received: ", result);
                        // response will be in JSON, e.g. {"server": "0xdeadbeef", "key": "0xdeadbeef"}
                        // which will give you serverId
                        var payload = JSON.parse(web3.toAscii(result.payload));

                        // no need to watch for the filter any more
                        filter.stopWatching();

                        // ok, at this point we have Chat Session SymKey, and we can:
                        // 1. register our device with that chat
                        // 2. share that key with others, so that they can register themselves
                        // 3. use chat key to trigger notifications

                        // this obtained from https://status-sandbox-c1b34.firebaseapp.com/
                        var deviceId = 'ca5pRJc6L8s:APA91bHpYFtpxvXx6uOayGmnNVnktA4PEEZdquCCt3fWR5ldLzSy1A37Tsbzk5Gavlmk1d_fvHRVnK7xPAhFFl-erF7O87DnIEstW6DEyhyiKZYA4dXFh6uy323f9A3uw5hEtT_kQVhT';

                        registerDevice(web3, identity, chatId, payload.key, deviceId); // weird signature because we reuse method for Device B
                        shareChatKey(chatId, payload.key);

                        // now do a cleanup
                        removeClientSession();
                    }
                });

                var err = web3.shh.post({
                    from: identity,
                    topics: [newChatSessionTopic],
                    payload: '{"chat": "' + chatId + '"}', // globally unique chat Id
                    ttl: 20,
                    keyname: keyname
                });
                if (err !== null) {
                    console.log("message NOT sent")
                } else {
                    console.log("message sent OK")
                }
            };

            var watchServerAckResponses = function (identity) {
                // if server we accepted is ok, it will send encrypted (to you)
                // message, with a ACK_NOTIFICATION_SERVER_SUBSCRIPTION topic (for which we wait)
                // This message completes the subscription process. At this point you should
                // have topic and symkey necessary to manage your subscription.
                var filter = web3.shh.filter({
                    to: identity, // wait for anon. messages to ourselves
                    topics: [ackClientSubscriptionTopic]
                });
                filter.watch(function (error, result) {
                    if (!error) {
                        console.log("Server ACK received: ", result);
                        // response will be in JSON, e.g. {"server": "0xdeadbeef", "key": "0xdeadbeef"}
                        // which will give you serverId
                        var payload = JSON.parse(web3.toAscii(result.payload));
                        console.log(payload);

                        // no need to watch for the filter any more
                        filter.stopWatching();

                        // this concludes discovery, and we can use obtained key to invoke chat sessions
                        createChatSession(payload.key)
                    }
                });
            };

            var identity = web3.shh.newIdentity();
            console.log("identity used: ", identity)

            // check identity
            if (!web3.shh.hasIdentity(identity)) {
                throw 'idenitity "' + identity + '" not found in whisper';
            }

            watchProposeServerResponses(identity);
            watchServerAckResponses(identity);

            // start discovery protocol, by sending discovery request
            sendDiscoveryRequest(identity);
        };

        var startDeviceB = function () {
            var web3 = new Web3();
            web3.setProvider(new web3.providers.HttpProvider('http://localhost:8745'));

            // pre-defined test identity (it gets injected automatically by statusd)
            var identity = '0x04eedbaafd6adf4a9233a13e7b1c3c14461fffeba2e9054b8d456ce5f6ebeafadcbf3dce3716253fbc391277fa5a086b60b283daf61fb5b1f26895f456c2f31ae3';
            if (!web3.shh.hasIdentity(identity)) {
                throw 'idenitity "' + identity + '" not found in whisper';
            }

            // for for key sharing, it is up to you how you implement it (which topic to use etc)
            var filter = web3.shh.filter({
                to: identity, // wait for anon. messages to ourselves
                topics: ['chatKeySharing']
            });
            filter.watch(function (error, result) {
                if (!error) {
                    console.log("Chat key received: ", result);
                    // response will be in JSON, e.g. {chat: "0xdeadbeef", key: "0x04e68e37433baf55ddc2fe9f7533e4e722bcdad4239c98df92f3522907ced72d"}
                    var payload = JSON.parse(web3.toAscii(result.payload));
                    console.log(payload);

                    // no need to watch for the filter any more
                    filter.stopWatching();

                    // let's save incoming key
                    var keyname = payload.chat + '-chatkey';
                    web3.shh.deleteSymKey(keyname);
                    web3.shh.addSymKey(keyname, payload.key);

                    // now register ourselves
                    var deviceId = 'some-device-id'; // you obtain this from FCM
                    registerDevice(web3, identity, payload.chat, payload.key, deviceId);

                    // finally, trigger the notifications on all registered device (except for yourself)
                    // at this point it is really trivial, use the key + specific topic:
                    var err = web3.shh.post({
                        from: identity,
                        topics: [sendNotificationTopic],
                        payload: '{' // see https://firebase.google.com/docs/cloud-messaging/http-server-ref
                        + '"notification": {'
                            + '"title": "status.im notification",'
                            + '"body": "Hello this is test notification!",'
                            + '"icon": "https://status.im/img/logo.png",'
                            + '"click_action": "https://status.im"'
                        + '},'
                        + '"to": "{{ ID }}"' // this get replaced by device id your've registered
                        + '}',
                        ttl: 20,
                        keyname: keyname
                    });
                    if (err !== null) {
                        console.log("message NOT sent")
                    } else {
                        console.log("message sent OK")
                    }
                }
            });
            console.log("device b started")
        };

        startDeviceA();
        startDeviceB();

        $(document).ready(function () {
        });

    </script>

</head>

<body>
<!-- Static navbar -->
<nav class="navbar navbar-default navbar-static-top">
    <div class="container">
    </div>
</nav>

<div class="container">
    <div class="jumbotron">

    </div>
</div>


</body>

</html>
